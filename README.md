# Progress

Each day I use a different programming language.

## Day 1 - Squirrel

A simple language which does not seem to be developed for a while.
The language has documentation which is sufficient, however it lacks more examples.

The task itself was fairly simple, yet it allowed to look for a better than naive algorithm.

## Day 2 - Sed

It is well-known that sed is a very powerful tool, yet is it up to this task.
It certainly is and thanks to single-letter command names, the solution is even very short.

The task was mostly about organizing the input so that we could work with two consecutive characters.
Working with unary system was crucial and conversion between unary and decimal numbers was tedious.

## Day 3 - TCL

Very powerful minimalistic language; I like its rawness.
It has pretty good documentation with examples.

I was hoping that the second part of the task would be search for minimum over all slopes.
Maybe in some later task...

## Day 4 - D

After an intermezzo trying to learn and later failing to install Self on my 64bit system, I chose D as a language which should be simpler.
D was surprisingly easy; I quite like it, I definitely can it fitting between C and Go.
I could not make it work properly in Idea (https://github.com/intellij-dlanguage/intellij-dlanguage/issues/496),
so I had to look up everything in documentation or tutorials instead of relying on IntelliSense.

Task was easy; the second part had me learn pointers to functions, anonymous function in D which was much nicer than in C.

## Day 5 - Forth

I have read a lot about this minimalistic language, so I wanted to try it.
It is quite interesting to design a stack based program, although it was a mind-fuck from time to time.

The task would have been easy in any language.
The second part was very expected.

## Day 6 - Racket

Lisp/Scheme-like language which has pretty nice editor (`drrocket`), although it could have better integrated documentation.

The task was easily solved after finding out that the language has set operations (union and intersect).
A minor issue was that it does not have `fold1`.

## Day 7 - Bash

This finally forced me to learn bash extensions of Shell: arrays, associative arrays, namerefs.

Graph traversal was easy in the end.
I was worried that there would be cycles present and algorithm would have to be more complex, maybe later.
I remember a similar task from last(?) year. 

## Day 8 - Cobol

Another ancient language crossed from my list, and I don't want to see it ever again.
Cobol is so verbose, so weirdly structured.
I chose it because I dod not need dynamic allocation of memory for this task.

It was mostly about battling the language and reading documentation and forums mentioning mainframes.
I hope there won't bet too many virtual machine tasks as last year.

# Language Pool

C++
Eiffel
Java
Joy
Mercury
Oberon
Perl
PostScript
R
Scala
Scratch
Smalltalk
SQL
TeX
Vala
Vim Script
XQuery
Zig

# Banned

Self - does not have 64bit distribution
